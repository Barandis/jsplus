<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>combinators/pure - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-combinators.html">combinators</a><ul class='methods'><li data-type='method'><a href="module-combinators.html#.compose">compose</a></li><li data-type='method'><a href="module-combinators.html#.flip">flip</a></li><li data-type='method'><a href="module-combinators.html#.pipe">pipe</a></li></ul></li><li><a href="module-combinators_pure.html">combinators/pure</a><ul class='methods'><li data-type='method'><a href="module-combinators_pure.html#.B">B</a></li><li data-type='method'><a href="module-combinators_pure.html#.C">C</a></li><li data-type='method'><a href="module-combinators_pure.html#.I">I</a></li><li data-type='method'><a href="module-combinators_pure.html#.Is">Is</a></li><li data-type='method'><a href="module-combinators_pure.html#.K">K</a></li><li data-type='method'><a href="module-combinators_pure.html#.Psi">Psi</a></li><li data-type='method'><a href="module-combinators_pure.html#.S">S</a></li><li data-type='method'><a href="module-combinators_pure.html#.Sp">Sp</a></li><li data-type='method'><a href="module-combinators_pure.html#.T">T</a></li><li data-type='method'><a href="module-combinators_pure.html#.W">W</a></li></ul></li><li><a href="module-functions.html">functions</a><ul class='methods'><li data-type='method'><a href="module-functions.html#.curry">curry</a></li><li data-type='method'><a href="module-functions.html#.curry2">curry2</a></li><li data-type='method'><a href="module-functions.html#.curry3">curry3</a></li><li data-type='method'><a href="module-functions.html#.curry4">curry4</a></li><li data-type='method'><a href="module-functions.html#.curry5">curry5</a></li><li data-type='method'><a href="module-functions.html#.curryn">curryn</a></li><li data-type='method'><a href="module-functions.html#.enumerate">enumerate</a></li><li data-type='method'><a href="module-functions.html#.partial">partial</a></li><li data-type='method'><a href="module-functions.html#.range">range</a></li><li data-type='method'><a href="module-functions.html#.scan">scan</a></li></ul></li><li><a href="module-operators.html">operators</a><ul class='methods'><li data-type='method'><a href="module-operators.html#.add">add</a></li><li data-type='method'><a href="module-operators.html#.ceq">ceq</a></li><li data-type='method'><a href="module-operators.html#.cne">cne</a></li><li data-type='method'><a href="module-operators.html#.div">div</a></li><li data-type='method'><a href="module-operators.html#.eq">eq</a></li><li data-type='method'><a href="module-operators.html#.ge">ge</a></li><li data-type='method'><a href="module-operators.html#.gt">gt</a></li><li data-type='method'><a href="module-operators.html#.le">le</a></li><li data-type='method'><a href="module-operators.html#.lt">lt</a></li><li data-type='method'><a href="module-operators.html#.mul">mul</a></li><li data-type='method'><a href="module-operators.html#.ne">ne</a></li><li data-type='method'><a href="module-operators.html#.neg">neg</a></li><li data-type='method'><a href="module-operators.html#.pos">pos</a></li><li data-type='method'><a href="module-operators.html#.pow">pow</a></li><li data-type='method'><a href="module-operators.html#.rem">rem</a></li><li data-type='method'><a href="module-operators.html#.sub">sub</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">combinators/pure</h1>
    

    




<section>

<header>
    
        
    
</header>

<article>
    
        <div class="container-overview">
        
            

            
        
        </div>
    

    

    

    
    
    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id=".B"><span class="type-signature">(static) </span>B<span class="signature">(a, b, c)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="combinators_pure_B.js.html">combinators/pure/B.js</a>, <a href="combinators_pure_B.js.html#line37">line 37</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The <strong>B</strong> combinator. This is the composition combinator.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type signature</td>
<td><code>(a -&gt; b) -&gt; (c -&gt; a) -&gt; c -&gt; b</code></td>
</tr>
<tr>
<td>Lambda representation</td>
<td><code>λxyz.x(yz)</code></td>
</tr>
<tr>
<td>SK system</td>
<td><code>S(KS)K</code></td>
</tr>
<tr>
<td>BCKW system</td>
<td><code>B</code></td>
</tr>
<tr>
<td>Bird</td>
<td>Bluebird</td>
</tr>
</tbody>
</table>
<p>The <strong>B</strong> combinator performs the composition of two single-parameter functions. This
means that the second function (<code>b</code>) is applied to an argument, and then the first
function (<code>a</code>) is applied to that result. This is the basic way of combining two
functions into another function that does the same thing as the two component functions
being applied in reverse order.</p>
<p>As the composition combinator, <strong>B</strong> has equivalent operators in many languages,
including <code>.</code> in Haskell, <code>∘</code> in APL, and <code>&amp;</code> in J. Concatenative languages (such as
Forth and Factor) are called concatenative because composition is done by simply naming
two functions next to each other (&quot;concatenating&quot; the functions).</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of one parameter. This function accepts the return value
from <code>b</code>, and this function's return value becomes the return value of the
combinator.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>b</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of one parameter. This function takes <code>c</code> as its argument,
and its return value becomes the argument to <code>a</code>.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>c</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value that becomes <code>b</code>'s argument.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The return value of function <code>a</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".C"><span class="type-signature">(static) </span>C<span class="signature">(a, b, c)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="combinators_pure_C.js.html">combinators/pure/C.js</a>, <a href="combinators_pure_C.js.html#line28">line 28</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The <strong>C</strong> combinator. This is the flip or swap combinator.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type signature</td>
<td><code>(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code></td>
</tr>
<tr>
<td>Lambda representation</td>
<td><code>λxyz.xzy</code></td>
</tr>
<tr>
<td>SK system</td>
<td><code>S(S(K(S(KS)K))S)(KK)</code></td>
</tr>
<tr>
<td>BCKW system</td>
<td><code>C</code></td>
</tr>
<tr>
<td>Bird</td>
<td>Cardinal</td>
</tr>
</tbody>
</table>
<p>The <strong>C</strong> combinator swaps the order of its second and third arguments <code>b</code> and <code>c</code> and
then applies the first argument function <code>a</code> to those arguments in their new order.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of two parameters. This function needs to be able to
accept <code>c</code> and <code>b</code> as arguments (in that order), and its return value will be the
combinator's return value.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>b</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value that will become <code>a</code>'s second argument.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>c</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value that will become <code>a</code>'s first argument.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The return value of function <code>a</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".I"><span class="type-signature">(static) </span>I<span class="signature">(a)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="combinators_pure_I.js.html">combinators/pure/I.js</a>, <a href="combinators_pure_I.js.html#line23">line 23</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The <strong>I</strong> combinator. This is the identity combinator.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type signature</td>
<td><code>a -&gt; a</code></td>
</tr>
<tr>
<td>Lambda representation</td>
<td><code>λx.x</code></td>
</tr>
<tr>
<td>SK system</td>
<td><code>SKK</code></td>
</tr>
<tr>
<td>BCKW system</td>
<td><code>WK</code></td>
</tr>
<tr>
<td>Bird</td>
<td>Identity bird</td>
</tr>
</tbody>
</table>
<p>The <strong>I</strong> combinator simply returns whatever value is passed to it.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value of any type.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The same value that was passed in as <code>a</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".Is"><span class="type-signature">(static) </span>Is<span class="signature">(a, b)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="combinators_pure_Is.js.html">combinators/pure/Is.js</a>, <a href="combinators_pure_Is.js.html#line29">line 29</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The <strong>I*</strong> combinator. This is the function application combinator.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type signature</td>
<td><code>(a -&gt; b) -&gt; a -&gt; b</code></td>
</tr>
<tr>
<td>Lambda representation</td>
<td><code>λxy.xy</code></td>
</tr>
<tr>
<td>SK system</td>
<td><code>SK(SK)</code></td>
</tr>
<tr>
<td>BCKW system</td>
<td><code>BWK</code></td>
</tr>
<tr>
<td>Bird</td>
<td>Identity once removed</td>
</tr>
</tbody>
</table>
<p>The <strong>I*</strong> combinator represents normal function application. This is known in some
literature as the <strong>A</strong> combinator, but this does not appear to be widespread. It fits
with the concept in <em>To Mock a Mockingbird</em> of starred combinators that represent a
combinator's action &quot;once removed&quot;, and while <strong>I*</strong> doesn't appear in that book, other
starred combinators that are derived similarly do.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of one parameter. This will receive <code>b</code> as an argument and
its return value becomes the combinator's return value.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>b</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value that is given to <code>a</code> as its argument.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The return value of function <code>a</code> when applied to value <code>b</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".K"><span class="type-signature">(static) </span>K<span class="signature">(a)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="combinators_pure_K.js.html">combinators/pure/K.js</a>, <a href="combinators_pure_K.js.html#line35">line 35</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The <strong>K</strong> combinator. This is the constant combinator.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type signature</td>
<td><code>a -&gt; b -&gt; a</code></td>
</tr>
<tr>
<td>Lambda representation</td>
<td><code>λxy.x</code></td>
</tr>
<tr>
<td>SK system</td>
<td><code>K</code></td>
</tr>
<tr>
<td>BCKW system</td>
<td><code>K</code></td>
</tr>
<tr>
<td>Bird</td>
<td>Kestrel</td>
</tr>
</tbody>
</table>
<p>The <strong>K</strong> combinator produces functions (closures) that return the <strong>K</strong> combinator's
first argument, no matter what arguments are passed to the produced function.</p>
<p>For this reason the type signature given above doesn't really match the JavaScript
implementation's type signature. There is no equivalent to the <code>b</code> parameter in the type
signature above; it's not considered good style to include a parameter that doesn't get
referenced in the body of the function. Besides, the produced function, like all
JavaScript functions, can take arbitrary arguments even if the parameter list is empty.
These arguments are simply ignored, which is exactly the desired effect anyway.</p>
<p>The <strong>K</strong> combinator is one of the two primitive combinators of the SK calculus. This
means that any possible computation can be performed as sequences of these two
combinators.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value that will be returned by the returned constant function.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A function which ignores its argument(s) and returns <code>a</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".Psi"><span class="type-signature">(static) </span>Psi<span class="signature">(a, b, c, d)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="combinators_pure_Psi.js.html">combinators/pure/Psi.js</a>, <a href="combinators_pure_Psi.js.html#line39">line 39</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The <strong>Ψ</strong> (psi) combinator.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type signature</td>
<td><code>(a -&gt; a -&gt; b) -&gt; (c -&gt; a) -&gt; c -&gt; c -&gt; b</code></td>
</tr>
<tr>
<td>Lambda representation</td>
<td><code>λxyzw.x(yz)(yw)</code></td>
</tr>
</tbody>
</table>
<p>The <strong>Ψ</strong> combinator applies its second argument separately to its third and fourth
arguments, and then it applies its first argument to the two results. This has the effect
of passing two arguments, separately, to a unary function and then combining the results
with a binary function.</p>
<p>This is similar to the <strong><a href="module-combinators_pure.html#.Sp">S'</a></strong> combinator, except that
instead of using one value applied to two different unary functions, it uses two
different values applied to a single unary function.</p>
<p>This is called the <strong>P</strong> combinator in the fantasy-land spec, which is convenient because
there really isn't another P combinator, but it's called &quot;psi&quot; in nearly every other
instance (both in languages and literature). It does not appear in <em>To Mock a
Mockingbird</em>.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of two parameters. It's applied to the return values of
both applications of function <code>b</code>. Its return value becomes the return value of the
combinator.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>b</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of one parameter. It's applied separately to the values
<code>c</code> and <code>d</code>, and those return values are provided as arguments to function <code>a</code>.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>c</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value to which function <code>b</code> is applied.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>d</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value to which function <code>b</code> is applied.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The result of function <code>a</code> being applied to the results of function <code>b</code>'s
applications to each of <code>c</code> and <code>d</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".S"><span class="type-signature">(static) </span>S<span class="signature">(a, b, c)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="combinators_pure_S.js.html">combinators/pure/S.js</a>, <a href="combinators_pure_S.js.html#line42">line 42</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The <strong>S</strong> combinator. This is the substitution combinator.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type signature</td>
<td><code>(a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code></td>
</tr>
<tr>
<td>Lambda representation</td>
<td><code>λxyz.xz(yz)</code></td>
</tr>
<tr>
<td>SK system</td>
<td><code>S</code></td>
</tr>
<tr>
<td>BCKW system</td>
<td><code>B(BW)(BBC)</code></td>
</tr>
<tr>
<td>Bird</td>
<td>Starling</td>
</tr>
</tbody>
</table>
<p>The idea of substitution comes from the fact that, rather than merely applying <code>a</code> to
<code>b</code>, it first <em>substitutes</em> them both by applying a third argument <code>c</code> to each of them
before performing that application.</p>
<p>(In fact, Moses Schönfinkel named this combinator &quot;<strong>S</strong>&quot; in 1924, where the combinator's
name in German was <em>Verschmelzungsfunktion</em> or &quot;fusion function&quot;. The <strong>S</strong> was to avoid
confusion with another combinator that he named <em>Vertauschungsfunktion</em> (&quot;swap
function&quot;); rather than name either of them <strong>V</strong>, he went with the first letters of the
roots <em>schmelzen</em> and <em>tauschen</em>. The latter he called <strong>T</strong>, which Haskell Curry renamed
to <strong>C</strong> in 1930. Curry chose to keep <strong>S</strong> though.)</p>
<p>The <strong>S</strong> combinator is one of the two primitive combinators of the SK calculus. This
means that any possible computation can be performed as sequences of these two
combinators.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of two parameters. It will take as arguments the value <code>c</code>
and the return value of function <code>b</code>. This function's return value becomes the
return value of the combinator.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>b</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of one parameter. Its argument will be the value <code>c</code>, and
its return value will become the second argument of function <code>a</code>.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>c</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value which becomes the first argument of both function <code>a</code> and function
<code>b</code>.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The value returned by function <code>a</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".Sp"><span class="type-signature">(static) </span>Sp<span class="signature">(a, b, c, d)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="combinators_pure_Sp.js.html">combinators/pure/Sp.js</a>, <a href="combinators_pure_Sp.js.html#line39">line 39</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The <strong>S'</strong> combinator.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type signature</td>
<td><code>(b -&gt; c -&gt; d) -&gt; (a -&gt; b) -&gt; (a -&gt; c) -&gt; a -&gt; d</code></td>
</tr>
<tr>
<td>Lambda representation</td>
<td><code>λxyzw.x(yw)(zw)</code></td>
</tr>
</tbody>
</table>
<p>The <strong>S'</strong> combinator applies both its second and third arguments separately to its
fourth argument, then it applies its first argument to the two results. This has the
effect of passing an argument to two different unary functions and then combining the
results with a binary function.</p>
<p>This is similar to the <strong><a href="module-combinators_pure.html#.Psi">Ψ</a></strong> combinator, except that
instead of using two different values applied to one unary function, it uses one value
applied to two different unary functions.</p>
<p>This is a commonly seen combinator in functional and array languages. It is <code>liftA2</code> in
Haskell and is represented by the fork construction that originated in J and worked its
way into some modern dialects of APL. As such it's very useful in point-free programming.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of two parameters. It's applied to the return values of
the applications of functions <code>b</code> and <code>c</code>. Its return value becomes the return value
of the combinator.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>b</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of one parameter. It's applied to the value <code>d</code> to produce
one of the arguments for function <code>a</code>.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>c</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of one parameter. It's applied to the value <code>d</code> to produce
one of the arguments for function <code>a</code>.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>d</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value to which functions <code>b</code> and <code>c</code> are applied.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The result of function <code>a</code> being applied to the results of function <code>b</code>'s
and function <code>c</code>'s applications to value <code>d</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".T"><span class="type-signature">(static) </span>T<span class="signature">(a, b)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="combinators_pure_T.js.html">combinators/pure/T.js</a>, <a href="combinators_pure_T.js.html#line28">line 28</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The <strong>T</strong> combinator. This is commonly known as the thrush combinator.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type signature</td>
<td><code>a -&gt; (a -&gt; b) -&gt; b</code></td>
</tr>
<tr>
<td>Lambda representation</td>
<td><code>λxy.yx</code></td>
</tr>
<tr>
<td>SK system</td>
<td><code>S(K(S(SKK)))K</code></td>
</tr>
<tr>
<td>BCKW system</td>
<td><code>C(WK)</code></td>
</tr>
<tr>
<td>Bird</td>
<td>Thrush</td>
</tr>
</tbody>
</table>
<p>The <strong>T</strong> combinator reverses function application, applying the function <code>b</code> to the
value <code>a</code>. This is a not-uncommon operation, and unlike many combinators, that operation
has adopted the bird name in many languages; i.e., both Haskell and Racket have a
<code>thrush</code> function.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value which gets passed to function <code>b</code>.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>b</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of one parameter. This gets applied to value <code>a</code> and the
return value becomes the return value of the combinator.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The value returned from applying function <code>b</code> to value <code>a</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".W"><span class="type-signature">(static) </span>W<span class="signature">(a, b)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="combinators_pure_W.js.html">combinators/pure/W.js</a>, <a href="combinators_pure_W.js.html#line27">line 27</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The <strong>W</strong> combinator. This is the duplicate combinator.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type signature</td>
<td><code>(a -&gt; a -&gt; b) -&gt; a -&gt; b</code></td>
</tr>
<tr>
<td>Lambda representation</td>
<td><code>λxy.xyy</code></td>
</tr>
<tr>
<td>SK system</td>
<td><code>SS(SK)</code></td>
</tr>
<tr>
<td>BCKW system</td>
<td><code>W</code></td>
</tr>
<tr>
<td>Bird</td>
<td>Warbler</td>
</tr>
</tbody>
</table>
<p>The <strong>W</strong> combinator duplicates its second argument <code>b</code> and then applies its first
argument <code>a</code> to both instances of <code>b</code>.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of two parameters. It will receive value <code>b</code> as both
arguments, and its return value will be the return value for the combinator.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>b</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A value of type T. This value is duplicated and passed (twice) to function
<code>a</code>.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The result of function <code>a</code> when applied to <code>b</code> twice.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
    

    

    
</article>

</section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>