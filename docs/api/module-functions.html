<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>functions - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-combinators.html">combinators</a><ul class='methods'><li data-type='method'><a href="module-combinators.html#.flip">flip</a></li></ul></li><li><a href="module-combinators_pure.html">combinators/pure</a><ul class='methods'><li data-type='method'><a href="module-combinators_pure.html#.B">B</a></li><li data-type='method'><a href="module-combinators_pure.html#.C">C</a></li><li data-type='method'><a href="module-combinators_pure.html#.I">I</a></li><li data-type='method'><a href="module-combinators_pure.html#.K">K</a></li><li data-type='method'><a href="module-combinators_pure.html#.S">S</a></li><li data-type='method'><a href="module-combinators_pure.html#.W">W</a></li></ul></li><li><a href="module-functions.html">functions</a><ul class='methods'><li data-type='method'><a href="module-functions.html#.curry">curry</a></li><li data-type='method'><a href="module-functions.html#.curry2">curry2</a></li><li data-type='method'><a href="module-functions.html#.curry3">curry3</a></li><li data-type='method'><a href="module-functions.html#.curry4">curry4</a></li><li data-type='method'><a href="module-functions.html#.curry5">curry5</a></li><li data-type='method'><a href="module-functions.html#.curryn">curryn</a></li><li data-type='method'><a href="module-functions.html#.enumerate">enumerate</a></li><li data-type='method'><a href="module-functions.html#.partial">partial</a></li><li data-type='method'><a href="module-functions.html#.range">range</a></li><li data-type='method'><a href="module-functions.html#.scan">scan</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">functions</h1>
    

    




<section>

<header>
    
        
    
</header>

<article>
    
        <div class="container-overview">
        
            

            
        
        </div>
    

    

    

    
    
    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id=".curry"><span class="type-signature">(static) </span>curry<span class="signature">(fn)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functions_curry.js.html">functions/curry.js</a>, <a href="functions_curry.js.html#line48">line 48</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Produces a curried function out of a regular function.</p>
<p>This curried function is quite flexible. If it is called with the same number of
arguments as the original function, then it will simply execute the original function.</p>
<p>However, if it is called with fewer arguments, it will return a function that takes only
the <em>remaining</em> arguments and still produces the same result. The returned function is
itself curried, so this process can be done again.</p>
<p>This currying function requires that its original function specify its arguments. It will
not work on functions that use <code>arguments</code> to determine its arguments. Rest parameters
and default parameters are not counted, so using this function with them will produce
curried functions that expect a number of arguments in total that do not include those
parameters (or anything after them).</p>
<p>If a function has already been curried by this function, or if it has less than two
arguments, passing that function to <code>curry</code> will be a no-op (the same function will be
returned without modification). A corollary is that <code>curry</code> will not curry a fully
curried function (one in which no parameter list has more than one parameter).</p>
<h1>Examples</h1>
<pre class="prettyprint source lang-javascript"><code>const sum = curry((a, b, c) => a + b + c)

// Each of the following are equivalent, and all print '6' to the console.
console.log(sum(1, 2, 3))
console.log(sum(1, 2)(3))
console.log(sum(1)(2, 3))
console.log(sum()(1, 2, 3))
console.log(sum(1)(2)(3))
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of any number of arguments.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new function that behaves as <code>fn</code>, unless it's called with fewer
arguments than the number given in <code>fn</code>'s definition. In this case, the new function
will return another new function that accepts the <em>rest</em> of the arguments.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".curry2"><span class="type-signature">(static) </span>curry2<span class="signature">(fn)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functions_curry2.js.html">functions/curry2.js</a>, <a href="functions_curry2.js.html#line31">line 31</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Curries a two-argument function.</p>
<p>Unlike in <code><a href="module-functions.html#.curry">curry</a></code>, the curried function so produced must
take its arguments one at a time. It will not accept multiple arguments within a single
set of parentheses. The advantage is that it works with functions that have rest or
default parameters.</p>
<h1>Examples</h1>
<pre class="prettyprint source lang-javascript"><code>const sum = curry2((a, b) => a + b)

// This is the only possible calling format.
console.log(sum(1)(2)) // 3

// This will not work. It is the same as sum(1) as the second argument is ignored.
console.log(sum(1, 2)) // function curry2(b)
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of two arguments.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A function that takes its arguments singly in two sets of
parentheses.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".curry3"><span class="type-signature">(static) </span>curry3<span class="signature">(fn)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functions_curry3.js.html">functions/curry3.js</a>, <a href="functions_curry3.js.html#line35">line 35</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Curries a three-argument function.</p>
<p>Unlike in <code><a href="module-functions.html#.curry">curry</a></code>, the curried function so produced must
take its arguments one at a time. It will not accept multiple arguments within a single
set of parentheses. The advantage is that it works with functions that have rest or
default parameters.</p>
<h1>Examples</h1>
<pre class="prettyprint source lang-javascript"><code>const sum = curry3((a, b, c) => a + b + c)

// This is the only possible calling format.
console.log(sum(1)(2)(3)) // 6

// This will not work. It is the same as sum(1)(3) as the second argument is ignored.
console.log(sum(1, 2)(3)) // function curry3(c)
// This will also not work. It's the same as sum(1)(2) as the third argument is ignored.
console.log(sum(1)(2, 3)) // function curry3(c)
// This is right out.
console.log(sum(1, 2, 3)) // function curry3(b)
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of three arguments.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A function that takes its arguments singly in three sets of
parentheses.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".curry4"><span class="type-signature">(static) </span>curry4<span class="signature">(fn)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functions_curry4.js.html">functions/curry4.js</a>, <a href="functions_curry4.js.html#line35">line 35</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Curries a four-argument function.</p>
<p>Unlike in <code><a href="module-functions.html#.curry">curry</a></code>, the curried function so produced must
take its arguments one at a time. It will not accept multiple arguments within a single
set of parentheses. The advantage is that it works with functions that have rest or
default parameters.</p>
<h1>Examples</h1>
<pre class="prettyprint source lang-javascript"><code>const sum = curry4((a, b, c, d) => a + b + c + d)

// This is the only possible calling format.
console.log(sum(1)(2)(3)(4)) // 10

// This will not work. It is the same as sum(1)(3)(4) as the second argument is ignored.
console.log(sum(1, 2)(3)(4)) // function curry4(d)
// This will not work. It's the same as sum(1)(2)(4) as the third argument is ignored.
console.log(sum(1)(2, 3)(4)) // function curry4(d)
// This is right out.
console.log(sum(1, 2, 3, 4)) // function curry4(b)
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of four arguments.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A function that takes its arguments singly in four sets of
parentheses.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".curry5"><span class="type-signature">(static) </span>curry5<span class="signature">(fn)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functions_curry5.js.html">functions/curry5.js</a>, <a href="functions_curry5.js.html#line35">line 35</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Curries a five-argument function.</p>
<p>Unlike in <code><a href="module-functions.html#.curry">curry</a></code>, the curried function so produced must
take its arguments one at a time. It will not accept multiple arguments within a single
set of parentheses. The advantage is that it works with functions that have rest or
default parameters.</p>
<h1>Examples</h1>
<pre class="prettyprint source lang-javascript"><code>const sum = curry4((a, b, c, d, e) => a + b + c + d + e)

// This is the only possible calling format.
console.log(sum(1)(2)(3)(4)(5)) // 15

// This is the same as sum(1)(3)(4)(5) as the second argument is ignored.
console.log(sum(1, 2)(3)(4)(5)) // function curry5(e)
// This is the same as sum(1)(2)(4)(5) as the third argument is ignored.
console.log(sum(1)(2, 3)(4)(5)) // function curry5(e)
// This is right out.
console.log(sum(1, 2, 3, 4, 5)) // function curry5(b)
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A function of five arguments.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A function that takes its arguments singly in five sets of
parentheses.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".curryn"><span class="type-signature">(static) </span>curryn<span class="signature">(n, fn)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functions_curryn.js.html">functions/curryn.js</a>, <a href="functions_curryn.js.html#line43">line 43</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Curries a function with an arbitrary number of arguments.</p>
<p>This function behaves much like <code><a href="module-functions.html#.curry2">curry2</a></code>,
<code><a href="module-functions.html#.curry3">curry3</a></code>, <code><a href="module-functions.html#.curry4">curry4</a></code>, and
<code><a href="module-functions.html#.curry5">curry5</a></code> in that arguments must be provided in sets of
parentheses with no more than one argument within each set. In fact, passing the
appropriate number as the first parameter to this function will make it act just like any
of those listed (i.e., <code>curryn(2, fn)</code> will behave the same as <code>curry2(fn)</code>). However, if
the number of arguments is known at write-time, it's best to use the specific function
for that number of arguments as it will be faster.</p>
<p>Rather, this function is useful in two cases: when you either don't know until runtime
how many arguments a function will be using, or when you want to curry a function of more
than 5 arguments (because there is no specific curry function for parameter lists that
large).</p>
<h1>Examples</h1>
<pre class="prettyprint source lang-javascript"><code>// variadic function, will sum any number of numbers given to it
const sum = (...ns) => ns.reduce((a, b) => a + b, 0)

const sum2 = curryn(2, sum)
console.log(sum2(1)(2))             // 3

const sum6 = curryn(6, sum)
console.log(sum6(1)(2)(3)(4)(5)(6)) // 21
console.log(sum6(1)(2)(3)(4)(5))    // function curried(a)
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>n</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>The number of arguments that the function to be curried has.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The function to be curried.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A single-argument function that returns another single-argument
function, and so on, <code>n</code> times.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".enumerate"><span class="type-signature">(generator, static) </span>enumerate<span class="signature">(iterable, start<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {array}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functions_enumerate.js.html">functions/enumerate.js</a>, <a href="functions_enumerate.js.html#line29">line 29</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Generates a set of pairs of iterable elements with their indices. This is inspired by
Python's <code>enumerate</code> function.</p>
<p>For arrays, these two statements do the same thing:</p>
<ul>
<li><code>for (const [i, value] of array.entries()) { ... }</code></li>
<li><code>for (const [i, value] of enumerate(array)) { ... }</code></li>
</ul>
<p>The difference is that <code>enumerate</code> works on <em>any</em> iterable, not only those that have
<code>entries</code> defined upon them.</p>
<p>This function also provides the option to start the index (the first element of the
yielded tuple) from a number other than 0. This number can be passed in as the optional
<code>start</code> parameter.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">iterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The iterable to be enumerated.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>start</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>0</code>
                
                </td>
            

            <td class="description last"><p>The index of the first tuple that gets yielded. Every
succeeding tuple has its index incremented by 1.</p></td>
        </tr>

    
    </tbody>
</table>

















		
<h5>Yields:</h5>		
		
        
<div class="param-desc">
    A tuple of the index of a value in the iterable and the value
    itself.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">array</span>


    </dd>
</dl>
		
    

        
            

    

    <h4 class="name" id=".partial"><span class="type-signature">(static) </span>partial<span class="signature">(fn, &hellip;args)</span><span class="type-signature"> &rarr; {function}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functions_partial.js.html">functions/partial.js</a>, <a href="functions_partial.js.html#line40">line 40</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Partially applies arguments to a function, resulting in another function that takes the
rest of the arguments.</p>
<p>Unlike <a href="module-functions.html#.curry">curry</a>, this function also takes some arguments
(hence it being partial application and not currying). It returns a function that takes
more arguments, and calling <em>that</em> function will result in an answer.</p>
<p>Note that this function always returns a function, even when provided enough arguments to
satisfy the function it partially completes. Another call (presumably with empty
parentheses) will have to be made to get the return value.</p>
<h1>Examples</h1>
<pre class="prettyprint source lang-javascript"><code>const sum = partial((a, b, c) => a + b + c, 1, 2)

console.log(sum(3))    // 6
console.log(sum(10))   // 13
console.log(sum(1001)) // 1004

// This still returns a function even though three arguments have been supplied.
const prod = partial((a, b, c) => a * b * c, 2, 3, 4)

// The function still needs to be invoked to get the answer.
console.log(prod())    // 24
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last"><p>The function to be partially applied.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>args</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                    &lt;repeatable><br>
                
                </td>
            

            

            <td class="description last"><p>The arguments to partially apply to <code>fn</code>.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new function that takes a variable number of arguments and applies
them after <code>args</code> are applied.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".range"><span class="type-signature">(generator, static) </span>range<span class="signature">(start<span class="signature-attributes">opt</span>, end, step<span class="signature-attributes">opt</span>, inclusive<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {number}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functions_range.js.html">functions/range.js</a>, <a href="functions_range.js.html#line75">line 75</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Generates a range of numbers. This is inspired by Python's <code>range</code> function.</p>
<p>This generator yields a range of numbers, starting with <code>start</code> and incrementing each
succeeding number by <code>step</code> until <code>end</code> is reached. If <code>inclusive</code> is true, then <code>end</code>
itself can be included in the range.</p>
<p>If only one numeric parameter is provided, it is assumed to be <code>end</code>. Two numbers are
interpreted as <code>start</code> and <code>end</code>. In any cases where they aren't specified, <code>start</code> is
<code>0</code> and <code>step</code> is <code>1</code>.</p>
<p>If <code>start</code> is greater than <code>end</code>, the range will run in reverse. In this case, each
successive number is <em>de</em>cremented by <code>step</code>. <code>step</code> itself should always be positive; if
a negative <code>step</code> is provided, its absolute value will be used instead, and if <code>0</code> is
provided, it will be regarded as <code>1</code>. The direction of the iteration is always determined
by <code>start</code> and <code>end</code>.</p>
<h1>Examples</h1>
<pre class="prettyprint source lang-javascript"><code>// Taking advantage of the fact that `range` is an iterator by using
// the spread operator to make arrays out of it
const e = [...range(4)]
console.log(e)    // [0,1,2,3]

const ei = [...range(4, true)]
console.log(ei)   // [0,1,2,3,4]

const se = [...range(2, 4)]
console.log(se)   // [2,3]

// 0 is necessary because range(4, 2) would be interpreted as a
// start of 4 and end of 2, producing [4,3]
const sep = [...range(0, 4, 2)]
console.log(sep)  // [0,2]

const sepi = [...range(0, 4, 2, true)]
console.log(sepi) // [0,2,4]

// Probably the most common use: in `for...of` loops
const a = [0, 1, 2, 3]
const b = [0, 5, 10, 15]
const c = []
// reversed; range produces 3, 2, 1, 0
for (const i of range(3, 0, true)) {
  c.push(a[i] * b[i])
}
console.log(c)    // [45,20,5,0]

// Sometimes you just need a loop to run x times without caring
// about the index; suggest using _ in that case
function line(length) {
  let result = ''
  for (const _ of range(length)) result += '-'
  return result
}
console.log(line(10))  // &quot;----------&quot;
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>start</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>0</code>
                
                </td>
            

            <td class="description last"><p>The first number of the range.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>end</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The last number of the range. By default this number forms the upper
bound of the range without being included in it.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>step</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>1</code>
                
                </td>
            

            <td class="description last"><p>The number to increase the yielded value by during each
iteration.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>inclusive</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>false</code>
                
                </td>
            

            <td class="description last"><p>Determines whether <code>end</code> should be included as part of
the range.</p></td>
        </tr>

    
    </tbody>
</table>

















		
<h5>Yields:</h5>		
		
        
<div class="param-desc">
    The values that make up the range.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">number</span>


    </dd>
</dl>
		
    

        
            

    

    <h4 class="name" id=".scan"><span class="type-signature">(static) </span>scan<span class="signature">(iterable, reducer, initial)</span><span class="type-signature"> &rarr; {array}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="functions_scan.js.html">functions/scan.js</a>, <a href="functions_scan.js.html#line29">line 29</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Reduces a collection, returning all of the intermediate reduction values. This is the
same as a <code>reduce</code> function except that it collects all intermediate results while
<code>reduce</code> will only return the final result.</p>
<h1>Examples</h1>
<pre class="prettyprint source lang-javascript"><code>const array = [1, 2, 3, 4, 5]
const sum = (a, b) => a + b

const results = scan(array, sum, 0)
console.log(results)  // [1,3,6,10,15]
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">iterable</span>


            
            </td>

            

            

            <td class="description last"><p>The iterable supplying values to the reducer function.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The reducer function, taking a result and a value and
returning the two reduced together.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>initial</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The initial value provided to the reducer function on its first call.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A collection of all of the values returned by the reducer function. This
array will have one element for each time the reducer function was executed.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">array</span>


    </dd>
</dl>

    



        
    

    

    
</article>

</section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>