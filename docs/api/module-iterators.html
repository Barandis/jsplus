<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>iterators - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-combinators.html">combinators</a><ul class='methods'><li data-type='method'><a href="module-combinators.html#.compose">compose</a></li><li data-type='method'><a href="module-combinators.html#.pipe">pipe</a></li><li data-type='method'><a href="module-combinators.html#.rotl">rotl</a></li><li data-type='method'><a href="module-combinators.html#.rotr">rotr</a></li><li data-type='method'><a href="module-combinators.html#.swap">swap</a></li></ul></li><li><a href="module-combinators_pure.html">combinators/pure</a><ul class='methods'><li data-type='method'><a href="module-combinators_pure.html#.B">B</a></li><li data-type='method'><a href="module-combinators_pure.html#.C">C</a></li><li data-type='method'><a href="module-combinators_pure.html#.Cs">Cs</a></li><li data-type='method'><a href="module-combinators_pure.html#.I">I</a></li><li data-type='method'><a href="module-combinators_pure.html#.Is">Is</a></li><li data-type='method'><a href="module-combinators_pure.html#.K">K</a></li><li data-type='method'><a href="module-combinators_pure.html#.Psi">Psi</a></li><li data-type='method'><a href="module-combinators_pure.html#.R">R</a></li><li data-type='method'><a href="module-combinators_pure.html#.Rs">Rs</a></li><li data-type='method'><a href="module-combinators_pure.html#.S">S</a></li><li data-type='method'><a href="module-combinators_pure.html#.Sp">Sp</a></li><li data-type='method'><a href="module-combinators_pure.html#.T">T</a></li><li data-type='method'><a href="module-combinators_pure.html#.W">W</a></li></ul></li><li><a href="module-functions.html">functions</a><ul class='methods'><li data-type='method'><a href="module-functions.html#.curry">curry</a></li><li data-type='method'><a href="module-functions.html#.curry2">curry2</a></li><li data-type='method'><a href="module-functions.html#.curry3">curry3</a></li><li data-type='method'><a href="module-functions.html#.curry4">curry4</a></li><li data-type='method'><a href="module-functions.html#.curry5">curry5</a></li><li data-type='method'><a href="module-functions.html#.curryn">curryn</a></li><li data-type='method'><a href="module-functions.html#.partial">partial</a></li></ul></li><li><a href="module-iterators.html">iterators</a><ul class='methods'><li data-type='method'><a href="module-iterators.html#.enumerate">enumerate</a></li><li data-type='method'><a href="module-iterators.html#.infinite">infinite</a></li><li data-type='method'><a href="module-iterators.html#.iterator">iterator</a></li><li data-type='method'><a href="module-iterators.html#.map">map</a></li><li data-type='method'><a href="module-iterators.html#.range">range</a></li><li data-type='method'><a href="module-iterators.html#.reduce">reduce</a></li><li data-type='method'><a href="module-iterators.html#.scan">scan</a></li></ul></li><li><a href="module-operators.html">operators</a><ul class='methods'><li data-type='method'><a href="module-operators.html#.add">add</a></li><li data-type='method'><a href="module-operators.html#.band">band</a></li><li data-type='method'><a href="module-operators.html#.bls">bls</a></li><li data-type='method'><a href="module-operators.html#.bnot">bnot</a></li><li data-type='method'><a href="module-operators.html#.bor">bor</a></li><li data-type='method'><a href="module-operators.html#.brs">brs</a></li><li data-type='method'><a href="module-operators.html#.burs">burs</a></li><li data-type='method'><a href="module-operators.html#.bxor">bxor</a></li><li data-type='method'><a href="module-operators.html#.ceq">ceq</a></li><li data-type='method'><a href="module-operators.html#.cne">cne</a></li><li data-type='method'><a href="module-operators.html#.coal">coal</a></li><li data-type='method'><a href="module-operators.html#.cond">cond</a></li><li data-type='method'><a href="module-operators.html#.div">div</a></li><li data-type='method'><a href="module-operators.html#.eq">eq</a></li><li data-type='method'><a href="module-operators.html#.ge">ge</a></li><li data-type='method'><a href="module-operators.html#.gt">gt</a></li><li data-type='method'><a href="module-operators.html#.land">land</a></li><li data-type='method'><a href="module-operators.html#.le">le</a></li><li data-type='method'><a href="module-operators.html#.lnot">lnot</a></li><li data-type='method'><a href="module-operators.html#.lor">lor</a></li><li data-type='method'><a href="module-operators.html#.lt">lt</a></li><li data-type='method'><a href="module-operators.html#.mul">mul</a></li><li data-type='method'><a href="module-operators.html#.ne">ne</a></li><li data-type='method'><a href="module-operators.html#.neg">neg</a></li><li data-type='method'><a href="module-operators.html#.opt">opt</a></li><li data-type='method'><a href="module-operators.html#.plus">plus</a></li><li data-type='method'><a href="module-operators.html#.pow">pow</a></li><li data-type='method'><a href="module-operators.html#.prop">prop</a></li><li data-type='method'><a href="module-operators.html#.rem">rem</a></li><li data-type='method'><a href="module-operators.html#.sub">sub</a></li></ul></li><li><a href="module-primitives.html">primitives</a><ul class='methods'><li data-type='method'><a href="module-primitives.html#.bigint">bigint</a></li><li data-type='method'><a href="module-primitives.html#.boolean">boolean</a></li><li data-type='method'><a href="module-primitives.html#.number">number</a></li><li data-type='method'><a href="module-primitives.html#.string">string</a></li><li data-type='method'><a href="module-primitives.html#.symbol">symbol</a></li></ul></li><li><a href="module-utilities.html">utilities</a><ul class='methods'><li data-type='method'><a href="module-utilities.html#.isArray">isArray</a></li><li data-type='method'><a href="module-utilities.html#.isFunction">isFunction</a></li><li data-type='method'><a href="module-utilities.html#.isNumber">isNumber</a></li><li data-type='method'><a href="module-utilities.html#.isObject">isObject</a></li><li data-type='method'><a href="module-utilities.html#.isString">isString</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">iterators</h1>
    

    




<section>

<header>
    
        
    
</header>

<article>
    
        <div class="container-overview">
        
            

            
        
        </div>
    

    

    

    
    
    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id=".enumerate"><span class="type-signature">(generator, static) </span>enumerate<span class="signature">(iterable, start<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {array}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_enumerate.js.html">iterators/enumerate.js</a>, <a href="iterators_enumerate.js.html#line29">line 29</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Generates a set of pairs of iterable elements with their indices. This is inspired by
Python's <code>enumerate</code> function.</p>
<p>For arrays, these two statements do the same thing:</p>
<ul>
<li><code>for (const [i, value] of array.entries()) { ... }</code></li>
<li><code>for (const [i, value] of enumerate(array)) { ... }</code></li>
</ul>
<p>The difference is that <code>enumerate</code> works on <em>any</em> iterable, not only those that have
<code>entries</code> defined upon them.</p>
<p>This function also provides the option to start the index (the first element of the
yielded tuple) from a number other than 0. This number can be passed in as the optional
<code>start</code> parameter.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">iterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The iterable to be enumerated.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>start</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>0</code>
                
                </td>
            

            <td class="description last"><p>The index of the first tuple that gets yielded. Every
succeeding tuple has its index incremented by 1.</p></td>
        </tr>

    
    </tbody>
</table>

















		
<h5>Yields:</h5>		
		
        
<div class="param-desc">
    A tuple of the index of a value in the iterable and the value
    itself.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">array</span>


    </dd>
</dl>
		
    

        
            

    

    <h4 class="name" id=".infinite"><span class="type-signature">(generator, static) </span>infinite<span class="signature">(start<span class="signature-attributes">opt</span>, step<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {number}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_infinite.js.html">iterators/infinite.js</a>, <a href="iterators_infinite.js.html#line35">line 35</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates an infinite iterator of numbers.</p>
<p>By default, the iterator starts at <code>0</code> and increases by 1 each invocation. Both of these
can be changed; the first argument is the starting value, and the second is the step
value.</p>
<p>This is much like <code><a href="module-iterators.html#.range">range</a></code> except that it doesn't have an
end or inclusive parameter and therefore does not, in fact, end. It can also be emulated
by passing a function to <code><a href="module-iterators.html#.iterator">iterator</a></code> that never returns
<code>undefined</code>. The <code>iterator</code> way allows more flexibility - it can emulate any series, not
just a linear one - but <code>infinite</code> is more convenient for the most usual cases.</p>
<pre class="prettyprint source lang-javascript"><code>const iter = infinite()
console.log(iter.next().value) // 0
console.log(iter.next().value) // 1
console.log(iter.next().value) // 2
...
console.log(iter.next().value) // 42
console.log(iter.next().value) // 43
...
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>start</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>0</code>
                
                </td>
            

            <td class="description last"><p>The beginning value for the iterator.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>step</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>1</code>
                
                </td>
            

            <td class="description last"><p>The number added to the current value for the next value.</p></td>
        </tr>

    
    </tbody>
</table>

















		
<h5>Yields:</h5>		
		
        
<div class="param-desc">
    The start value first, and then the last value plus the step value.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">number</span>


    </dd>
</dl>
		
    

        
            

    

    <h4 class="name" id=".iterator"><span class="type-signature">(static) </span>iterator<span class="signature">(x)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_iterator.js.html">iterators/iterator.js</a>, <a href="iterators_iterator.js.html#line170">line 170</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates an iterator over the provided value.</p>
<p>For values that implement the iterable protocol (i.e., that have properties named
<code>Symbol.iterator</code> that evaluate to functions), It's as simple as that. Therefore, arrays,
strings, and any custom objects that implement the iterable protocol work right out of
the box.</p>
<pre class="prettyprint source"><code>const iter = iterator([1, 2, 3]);

console.log(iter.next().value) // 1
console.log(iter.next().value) // 2
console.log(iter.next().value) // 3
console.log(iter.next().done)  // true
</code></pre>
<p>Generic objects get special support. If an object (meaning an object literal or something
created with <code>Object.create()</code>, but not custom classes, which have to implement the
iterable protocol explicitly) is passed to <code>iterator</code>, a new iterator will be returned
that iterates over everything that <code>Object.keys</code> returns for that object This will come
out in the &quot;natural&quot; property order, as follows:</p>
<ol>
<li>Integer indices, in numerical order. (This does include strings that convert to
integers, such as <code>'2'</code>, but not strings that do not directly correspond to an integer
even if they are convertible to integers, such as <code>'02'</code>.)</li>
<li>String property names, in the order in which they were added to the object.</li>
</ol>
<p>Symbol-keyed properties are not included by this iterator as symbols are intended to be
used for non-enumerable information (neither <code>Object.keys</code>, <code>Object.entries</code>, or
<code>for...in</code> loops include them either, even if they're made enumerable).</p>
<p>The values that this iterator provides are two-element arrays, in which the first element
is the key and the second is the value.</p>
<pre class="prettyprint source"><code>const iter = iterator({ b: 2, a: 4 });

console.log(iter.next().value) // ['b',2]
console.log(iter.next().value) // ['a',4]
console.log(iter.next().done)  // true
</code></pre>
<p>This does not modify the object itself, so it's not actually made &quot;iterable&quot; in any other
sense. It's explicit support for objects in this context and nothing more.</p>
<p>If this function is provided a <em>function</em> as its first argument, an iterator is returned
which runs that function one time for each call to <code>next</code>. That function is provided two
arguments: the index of the call (starting at <code>0</code> for the first time it's called and
increasing by 1 per invocation after that) and the return value of the previous call to
the function (starting at <code>undefined</code> for the first run before the function is ever
called). If the function ever returns <code>undefined</code>, the iterator will terminate and set
the <code>done</code> property of its return value to <code>true</code> at that point.</p>
<p>Note that since the initial value of the second argument is <code>undefined</code>, using default
arguments is an excellent way of providing the function an initial value.</p>
<pre class="prettyprint source"><code>const constIter = iterator(() => 6)   // Bert's favorite number
console.log(constIter.next().value)   // 6
console.log(constIter.next().value)   // 6
// This will go on forever, as long as `next` keeps getting called

const indexIter = iterator(x => x * x)
console.log(indexIter.next().value)   // 0
console.log(indexIter.next().value)   // 1
console.log(indexIter.next().value)   // 4
console.log(indexIter.next().value)   // 9
// Again, this will go on forever, or until the numbers get to big JS to handle

// Using default value on `last` parameter for initial value
const lastIter = iterator((index, last = 1) => last * (index + 1))  // Factorial
console.log(lastIter.next().value)    // 1
console.log(lastIter.next().value)    // 2
console.log(lastIter.next().value)    // 6
console.log(lastIter.next().value)    // 24
// Again, forever, though factorials get big quickly

// This iterator will terminate when the function returns `undefined`
const stopIter = iterator(x => x &lt; 2 ? x : undefined)
console.log(stopIter.next().value)    // 0
console.log(stopIter.next().value)    // 1
console.log(stopIter.next().done)     // true
</code></pre>
<p>If the argument is none of these things, then an iterator is returned that yields that
argument one time before completing.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to be iterated over.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator over the provided value. If the value is not iterable
(it's not an object or a function, and it doesn't have a protocol-defined iterator),
an iterator that returns only that value once is returned.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".map"><span class="type-signature">(generator, static) </span>map<span class="signature">(fn, iterable)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_map.js.html">iterators/map.js</a>, <a href="iterators_map.js.html#line31">line 31</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Passes each element of an iterable to a mapping function, returning the results in an
iterator.</p>
<p>This function comes pre-curried so it can be partially applied easily.</p>
<pre class="prettyprint source lang-javascript"><code>const result = map(add(1), [1, 2, 3])
console.log(result.next().value) // 2
console.log(result.next().value) // 3
console.log(result.next().value) // 4
console.log(result.next().done)  // true
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A one-parameter function. Each element of <code>iterable</code> is used as an
argument to this function, and its return values are yielded by the resulting
iterator.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">iterable</span>


            
            </td>

            

            

            <td class="description last"><p>The collection to map.</p></td>
        </tr>

    
    </tbody>
</table>

















		
<h5>Yields:</h5>		
		
        
<div class="param-desc">
    The return value of function `fn` when applied to the next value of
     `iterable`.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>
		
    

        
            

    

    <h4 class="name" id=".range"><span class="type-signature">(generator, static) </span>range<span class="signature">(start<span class="signature-attributes">opt</span>, end, step<span class="signature-attributes">opt</span>, inclusive<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {number}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_range.js.html">iterators/range.js</a>, <a href="iterators_range.js.html#line73">line 73</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Generates a range of numbers. This is inspired by Python's <code>range</code> function.</p>
<p>This generator yields a range of numbers, starting with <code>start</code> and incrementing each
succeeding number by <code>step</code> until <code>end</code> is reached. If <code>inclusive</code> is true, then <code>end</code>
itself can be included in the range.</p>
<p>If only one numeric parameter is provided, it is assumed to be <code>end</code>. Two numbers are
interpreted as <code>start</code> and <code>end</code>. In any cases where they aren't specified, <code>start</code> is
<code>0</code> and <code>step</code> is <code>1</code>.</p>
<p>If <code>start</code> is greater than <code>end</code>, the range will run in reverse. In this case, each
successive number is <em>de</em>cremented by <code>step</code>. <code>step</code> itself should always be positive; if
a negative <code>step</code> is provided, its absolute value will be used instead, and if <code>0</code> is
provided, it will be regarded as <code>1</code>. The direction of the iteration is always determined
by <code>start</code> and <code>end</code>.</p>
<pre class="prettyprint source lang-javascript"><code>// Taking advantage of the fact that `range` is an iterator by using
// the spread operator to make arrays out of it
const e = [...range(4)]
console.log(e)    // [0,1,2,3]

const ei = [...range(4, true)]
console.log(ei)   // [0,1,2,3,4]

const se = [...range(2, 4)]
console.log(se)   // [2,3]

// 0 is necessary because range(4, 2) would be interpreted as a
// start of 4 and end of 2, producing [4,3]
const sep = [...range(0, 4, 2)]
console.log(sep)  // [0,2]

const sepi = [...range(0, 4, 2, true)]
console.log(sepi) // [0,2,4]

// Probably the most common use: in `for...of` loops
const a = [0, 1, 2, 3]
const b = [0, 5, 10, 15]
const c = []
// reversed; range produces 3, 2, 1, 0
for (const i of range(3, 0, true)) {
  c.push(a[i] * b[i])
}
console.log(c)    // [45,20,5,0]

// Sometimes you just need a loop to run x times without caring
// about the index; suggest using _ in that case
function line(length) {
  let result = ''
  for (const _ of range(length)) result += '-'
  return result
}
console.log(line(10))  // &quot;----------&quot;
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>start</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>0</code>
                
                </td>
            

            <td class="description last"><p>The first number of the range.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>end</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The last number of the range. By default this number forms the upper
bound of the range without being included in it.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>step</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>1</code>
                
                </td>
            

            <td class="description last"><p>The number to increase the yielded value by during each
iteration.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>inclusive</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>false</code>
                
                </td>
            

            <td class="description last"><p>Determines whether <code>end</code> should be included as part of
the range.</p></td>
        </tr>

    
    </tbody>
</table>

















		
<h5>Yields:</h5>		
		
        
<div class="param-desc">
    The values that make up the range.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">number</span>


    </dd>
</dl>
		
    

        
            

    

    <h4 class="name" id=".reduce"><span class="type-signature">(static) </span>reduce<span class="signature">(fn, iterable)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_reduce.js.html">iterators/reduce.js</a>, <a href="iterators_reduce.js.html#line69">line 69</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Reduces an iterable with a function.</p>
<p>This function will apply the reducer function <code>fn</code> to the first two elements of the input
iterable, and then will apply the same reducer function to that result and the next
element of the iterable, repeating until there are no elements left. The result is a
single answer, which is returned.</p>
<p>As this function does not produce an iterator and needs to consume an entire iterable to
calculate its answer, it should not be used with an infinite iterator as the input.</p>
<p>Use of this function is done a little differently than traditional <code>Array.reduce</code>. It
does not have the option of an initial value. This means two things: first, the reduction
of a single-element iterable will just be that single element itself, and second, the
reducer function needs to have both arguments and the return value be of the same type.
This is contrary to <code>Array.reduce</code>, which has a first argument and return value of the
same type but which can take a different type for the second argument.</p>
<p>The upshot is that using a <code>map</code> before the <code>reduce</code> is suggested in many scenarios
where, in traditional JavaScript reduction, you would do that mapping as a part of the
reducer function itself. For example, if one wanted to turn an array of digits into
strings and then concatenate them, the <code>Array.reduce</code> way would be like this:</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (acc, value) => acc + value.toString()
function stringify(xs) {
  return xs.reduce(fn, '')
}
</code></pre>
<p>This maps the values in the middle of the reducer function (the <code>toString</code> call) and
wouldn't work as well with this iterator <code>reduce</code>. Instead, you would want to do this:</p>
<pre class="prettyprint source lang-javascript"><code>function stringify(xs) {
  const mapped = map(x => x.toString(), xs)
  return reduce((x, y) => x + y, mapped)
}
</code></pre>
<p>Though in reality, with the other functions in this library, it would be even better to
do this:</p>
<pre class="prettyprint source lang-javascript"><code>const stringify = compose(reduce(add), map(string))
</code></pre>
<p>Requiring the reducer function to take two arguments of the same type makes you have to
think more about the kind of reduction you want to do, but it makes it easier to use
functions you already have lying around to do things in a more concise and understandable
manner.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The reducer function, a function of two parameters that will receive
the current value and the next element as arguments.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The collection to reduce. This can be any type for which
<code><a href="module-iterators.html#.iterator">iterator</a></code> will produce a non-null value, meaning
objects, functions, or anything that implements the iterable protocol.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The result of the reducer function's last call.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".scan"><span class="type-signature">(generator, static) </span>scan<span class="signature">(fn, iterable)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_scan.js.html">iterators/scan.js</a>, <a href="iterators_scan.js.html#line67">line 67</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Reduces an iterable with a function, returning an iterator with all of the intermediate
results.</p>
<p>This acts very much like <code>reduce</code>, except instead of returning the final answer, it
returns the intermediate values from each time the function is run (in an iterator). The
first value is prepended unmodified to the iterator; this is to ensure that the length of
the result of <code>scan</code> is the same as the length of the input.</p>
<p>Use of this function is done a little differently than traditional <code>Array.reduce</code>. It
does not have the option of an initial value. The first calculated value is just the
result of the reducer function <code>fn</code> applied to the first two elements of the input. This
means that the reduction function needs to be able to handle both an input element and an
&quot;accumulator&quot; as its first argument.</p>
<p>Because the initial value in the result iterator will not be passed through the reducer
function, it's often best to use <code>map</code> before <code>scan</code> rather than depend on the reducer
function to do its own mapping, as is often done in JavaScript. For instance, if a
reducer function makes characters uppercase, it will still not affect the first value in
the output iterator; that value is never passed through the reducer function. Mapping to
uppercase and <em>then</em> scanning may be better.</p>
<p>Also, since the first invocation of the reducer function is sent two elements rather than
an accumulator value and an element, it's important to be sure that any &quot;mapping&quot; is done
on both arguments. For instance, a scan that is supposed to turn numbers into strings and
then concatenate them will have to be sure that <em>both</em> arguments are turned to strings,
since the first invocation will receive two numbers rather than a string and a number. It
would probably be best to map the numbers to strings <em>first</em> and then concatenate them
with <code>scan</code> after.</p>
<p><code>scan</code> is a curried function and can therefore easily be partially applied. It accepts
a reducer function that can be curried or uncurried.</p>
<pre class="prettyprint source lang-javascript"><code>const runningSum = scan(add, [0, 1, 2, 3, 4])
console.log(runningSum.next().value)  // 0
console.log(runningSum.next().value)  // 1
console.log(runningSum.next().value)  // 3
console.log(runningSum.next().value)  // 6
console.log(runningSum.next().value)  // 10

const mulScan = scan(mul)
const factorial = mulScan([1, 2, 3, 4, 5])
console.log(factorial.next().value)   // 1
console.log(factorial.next().value)   // 2
console.log(factorial.next().value)   // 6
console.log(factorial.next().value)   // 24
console.log(factorial.next().value)   // 120
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The reducer function, a function of two parameters that will receive
the current value and the next element as arguments.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The collection to scan. This can be any type for which
<code><a href="module-iterators.html#.iterator">iterator</a></code> will produce a non-null value, meaning
objects, functions, or anything that implements the iterable protocol.</p></td>
        </tr>

    
    </tbody>
</table>

















		
<h5>Yields:</h5>		
		
        
<div class="param-desc">
    The results of the reducer function as it is passed new elements.
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>
		
    

        
    

    

    
</article>

</section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>