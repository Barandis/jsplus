<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>iterators - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-combinators.html">combinators</a><ul class='methods'><li data-type='method'><a href="module-combinators.html#.compose">compose</a></li><li data-type='method'><a href="module-combinators.html#.composev">composev</a></li><li data-type='method'><a href="module-combinators.html#.constant">constant</a></li><li data-type='method'><a href="module-combinators.html#.identity">identity</a></li><li data-type='method'><a href="module-combinators.html#.pipe">pipe</a></li><li data-type='method'><a href="module-combinators.html#.pipev">pipev</a></li><li data-type='method'><a href="module-combinators.html#.rotl">rotl</a></li><li data-type='method'><a href="module-combinators.html#.rotr">rotr</a></li><li data-type='method'><a href="module-combinators.html#.substitute">substitute</a></li><li data-type='method'><a href="module-combinators.html#.swap">swap</a></li></ul></li><li><a href="module-combinators_pure.html">combinators/pure</a><ul class='methods'><li data-type='method'><a href="module-combinators_pure.html#.B">B</a></li><li data-type='method'><a href="module-combinators_pure.html#.C">C</a></li><li data-type='method'><a href="module-combinators_pure.html#.Cs">Cs</a></li><li data-type='method'><a href="module-combinators_pure.html#.I">I</a></li><li data-type='method'><a href="module-combinators_pure.html#.Is">Is</a></li><li data-type='method'><a href="module-combinators_pure.html#.K">K</a></li><li data-type='method'><a href="module-combinators_pure.html#.P">P</a></li><li data-type='method'><a href="module-combinators_pure.html#.Q">Q</a></li><li data-type='method'><a href="module-combinators_pure.html#.R">R</a></li><li data-type='method'><a href="module-combinators_pure.html#.Rs">Rs</a></li><li data-type='method'><a href="module-combinators_pure.html#.S">S</a></li><li data-type='method'><a href="module-combinators_pure.html#.Sp">Sp</a></li><li data-type='method'><a href="module-combinators_pure.html#.T">T</a></li><li data-type='method'><a href="module-combinators_pure.html#.W">W</a></li></ul></li><li><a href="module-functions.html">functions</a><ul class='methods'><li data-type='method'><a href="module-functions.html#.curry">curry</a></li><li data-type='method'><a href="module-functions.html#.curry2">curry2</a></li><li data-type='method'><a href="module-functions.html#.curry3">curry3</a></li><li data-type='method'><a href="module-functions.html#.curry4">curry4</a></li><li data-type='method'><a href="module-functions.html#.curry5">curry5</a></li><li data-type='method'><a href="module-functions.html#.curryv">curryv</a></li><li data-type='method'><a href="module-functions.html#.partial">partial</a></li><li data-type='method'><a href="module-functions.html#.uncurry">uncurry</a></li></ul></li><li><a href="module-iterators.html">iterators</a><ul class='methods'><li data-type='method'><a href="module-iterators.html#.array">array</a></li><li data-type='method'><a href="module-iterators.html#.collect">collect</a></li><li data-type='method'><a href="module-iterators.html#.concat">concat</a></li><li data-type='method'><a href="module-iterators.html#.count">count</a></li><li data-type='method'><a href="module-iterators.html#.drop">drop</a></li><li data-type='method'><a href="module-iterators.html#.enumerate">enumerate</a></li><li data-type='method'><a href="module-iterators.html#.filter">filter</a></li><li data-type='method'><a href="module-iterators.html#.iterate">iterate</a></li><li data-type='method'><a href="module-iterators.html#.map">map</a></li><li data-type='method'><a href="module-iterators.html#.range">range</a></li><li data-type='method'><a href="module-iterators.html#.reduce">reduce</a></li><li data-type='method'><a href="module-iterators.html#.reverse">reverse</a></li><li data-type='method'><a href="module-iterators.html#.scan">scan</a></li><li data-type='method'><a href="module-iterators.html#.take">take</a></li></ul></li><li><a href="module-operators.html">operators</a><ul class='methods'><li data-type='method'><a href="module-operators.html#.add">add</a></li><li data-type='method'><a href="module-operators.html#.band">band</a></li><li data-type='method'><a href="module-operators.html#.bls">bls</a></li><li data-type='method'><a href="module-operators.html#.bnot">bnot</a></li><li data-type='method'><a href="module-operators.html#.bor">bor</a></li><li data-type='method'><a href="module-operators.html#.brs">brs</a></li><li data-type='method'><a href="module-operators.html#.burs">burs</a></li><li data-type='method'><a href="module-operators.html#.bxor">bxor</a></li><li data-type='method'><a href="module-operators.html#.ceq">ceq</a></li><li data-type='method'><a href="module-operators.html#.cne">cne</a></li><li data-type='method'><a href="module-operators.html#.coal">coal</a></li><li data-type='method'><a href="module-operators.html#.cond">cond</a></li><li data-type='method'><a href="module-operators.html#.div">div</a></li><li data-type='method'><a href="module-operators.html#.eq">eq</a></li><li data-type='method'><a href="module-operators.html#.ge">ge</a></li><li data-type='method'><a href="module-operators.html#.gt">gt</a></li><li data-type='method'><a href="module-operators.html#.land">land</a></li><li data-type='method'><a href="module-operators.html#.le">le</a></li><li data-type='method'><a href="module-operators.html#.lnot">lnot</a></li><li data-type='method'><a href="module-operators.html#.lor">lor</a></li><li data-type='method'><a href="module-operators.html#.lt">lt</a></li><li data-type='method'><a href="module-operators.html#.mul">mul</a></li><li data-type='method'><a href="module-operators.html#.ne">ne</a></li><li data-type='method'><a href="module-operators.html#.neg">neg</a></li><li data-type='method'><a href="module-operators.html#.opt">opt</a></li><li data-type='method'><a href="module-operators.html#.plus">plus</a></li><li data-type='method'><a href="module-operators.html#.pow">pow</a></li><li data-type='method'><a href="module-operators.html#.prop">prop</a></li><li data-type='method'><a href="module-operators.html#.rem">rem</a></li><li data-type='method'><a href="module-operators.html#.sub">sub</a></li></ul></li><li><a href="module-primitives.html">primitives</a><ul class='methods'><li data-type='method'><a href="module-primitives.html#.bigint">bigint</a></li><li data-type='method'><a href="module-primitives.html#.boolean">boolean</a></li><li data-type='method'><a href="module-primitives.html#.number">number</a></li><li data-type='method'><a href="module-primitives.html#.string">string</a></li><li data-type='method'><a href="module-primitives.html#.symbol">symbol</a></li></ul></li><li><a href="module-utilities.html">utilities</a><ul class='methods'><li data-type='method'><a href="module-utilities.html#.isArray">isArray</a></li><li data-type='method'><a href="module-utilities.html#.isFunction">isFunction</a></li><li data-type='method'><a href="module-utilities.html#.isNumber">isNumber</a></li><li data-type='method'><a href="module-utilities.html#.isObject">isObject</a></li><li data-type='method'><a href="module-utilities.html#.isString">isString</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">iterators</h1>
    

    




<section>

<header>
    
        
    
</header>

<article>
    
        <div class="container-overview">
        
            

            
        
        </div>
    

    

    

    
    
    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id=".array"><span class="type-signature">(static) </span>array<span class="signature">(x)</span><span class="type-signature"> &rarr; {array}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_array.js.html">iterators/array.js</a>, <a href="iterators_array.js.html#line38">line 38</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Transforms an iterable into an array.</p>
<p>This is just a nice functional wrapper for <code>[...iterable]</code>, but since everything else is
functions, it looks nicer to have this be a function too. It's mostly for turning the
iterators that this module tends to provide into arrays, but it will work on any kind of
value under the same rules as <code><a href="module-iterators.html#.iterate">iterate</a></code>.</p>
<p>This function will always turn the input into an array. For a function that will turn
inputs also into strings or objects as appropriate, see
<code>collect</code></p>
<pre class="prettyprint source lang-javascript"><code>const iter = array (iterate ([1, 2, 3, 4, 5]))
const str = array ('test')
const obj = array ({a: 1, b: 2})
const fn = array (x => (x &lt; 5 ? x : undefined))
const single = array (4)

console.log(iter)   // [1, 2, 3, 4, 5]
console.log(str)    // [&quot;t&quot;, &quot;e&quot;, &quot;s&quot;, &quot;t&quot;]
console.log(obj)    // [[&quot;a&quot;, 1], [&quot;b&quot;, 2]]
console.log(fn)     // [0, 1, 2, 3, 4]
console.log(single) // [4]
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The object which is being made into an array.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An array version of the argument.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">array</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".collect"><span class="type-signature">(static) </span>collect<span class="signature">(x)</span><span class="type-signature"> &rarr; {array|object|string}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_collect.js.html">iterators/collect.js</a>, <a href="iterators_collect.js.html#line52">line 52</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Collects the elements of an iterable into a JavaScript collection of some kind.</p>
<p>This function is primarily for turning the iterators that are commonly returned by
various functions in this module into appropriate concrete collections. Working with
iterators all the way through is ideal, but at the end it's usual to need a concrete
collection to return.</p>
<p>The kind of output collection depends on the type of input. If the input is a string or a
collection of strings, the output will be a string. If the input is an object or a
collection of two-element arrays, the output will be an object. Otherwise the output will
be an array.</p>
<p>This does create the edge case of, for example, an iterator of two-element arrays that
you actually want to be an array. In that case, use
<code>array</code> instead.</p>
<p><strong><code>collect</code> is not lazy.</strong> By its nature, it must evaluate an entire iterator to work and
is thus not suitable for infinite iterators.</p>
<pre class="prettyprint source lang-javascript"><code>const arr = collect([1, 2, 3, 4, 5])
const str = collect('testing')
const obj = collect({ a: 1, b: 2, c: 3 })
const a2s = collect(['more', ' ', 't', 'est', 'i', 'n', 'g'])
const a2o = collect([[d, 4], [e, 5], [f, 6]])

console.log(arr) // [1, 2, 3, 4, 5]
console.log(str) // &quot;testing&quot;
console.log(obj) // { a: 1, b: 2, c: 3 }
console.log(a2s) // &quot;more testing&quot;
console.log(a2o) // { d: 4, e: 5, f: 6 }
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The input collection. This will be transformed into an iterator, so <code>x</code> can
be of any type (including non-collections).</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An output collection (not an iterator) depending on the
values in the input collection. If all input elements are strings, this will be a
string. If all input elements are two-element arrays, this will be an object.
Otherwise this will be an array.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">array</span>
|

<span class="param-type">object</span>
|

<span class="param-type">string</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".concat"><span class="type-signature">(generator, static) </span>concat<span class="signature">(x, y)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_concat.js.html">iterators/concat.js</a>, <a href="iterators_concat.js.html#line32">line 32</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Concatenates two collections. The result is an iterator that first yields elements of the
first collection, and when that is finished, the elements over the second collection.</p>
<p>This function works fine with infinite iterators, but be aware that if the first
collection is an infinite iterator, the second collection will never be iterated over.</p>
<pre class="prettyprint source lang-javascript"><code>const arrarr = concat ([1, 2, 3]) ([4, 5, 6])
const arrstr = concat ([1, 2, 3]) ('test')
const strstr = concat ('test') ('ing')

console.log(collect(arrarr)) // [1, 2, 3, 4, 5, 6]
console.log(collect(arrstr)) // [1, 2, 3, 't', 'e', 's', 't']
console.log(collect(strstr)) // &quot;testing&quot;
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The first collection to be concatenated.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>y</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The second collection to be concatenated.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator of all of the elements of <code>x</code> followed by all of the
elements of <code>y</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".count"><span class="type-signature">(generator, static) </span>count<span class="signature">(start<span class="signature-attributes">opt</span>, step<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_count.js.html">iterators/count.js</a>, <a href="iterators_count.js.html#line39">line 39</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates an infinite iterator that counts from a starting point.</p>
<p>By default, the iterator starts at <code>0</code> and increases by 1 each invocation. Both of these
can be changed; the first argument is the starting value, and the second is the step
value.</p>
<p>This function can count backwards by choosing a negative step, and it can create an
infinite series of the same number by choosing a step of <code>0</code>.</p>
<p>This is much like <code><a href="module-iterators.html#.range">range</a></code> except that it doesn't have an
end or inclusive parameter and therefore does not, in fact, end. It can also be emulated
by passing a function to <code><a href="module-iterators.html#.iterate">iterate</a></code> that never returns
<code>undefined</code>. The <code>iterate</code> way allows more flexibility - it can emulate any series, not
just a linear one - but <code>infinite</code> is more convenient for the most usual cases.</p>
<pre class="prettyprint source lang-javascript"><code>const iter = count()
console.log(iter.next().value) // 0
console.log(iter.next().value) // 1
console.log(iter.next().value) // 2
...
console.log(iter.next().value) // 42
console.log(iter.next().value) // 43
...
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>start</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>0</code>
                
                </td>
            

            <td class="description last"><p>The beginning value for the iterator.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>step</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>1</code>
                
                </td>
            

            <td class="description last"><p>The number added to the current value for the next value.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An infinite iterator starting at <code>start</code> and increasing by <code>step</code> on
each iteration.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".drop"><span class="type-signature">(generator, static) </span>drop<span class="signature">(n, x)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_drop.js.html">iterators/drop.js</a>, <a href="iterators_drop.js.html#line30">line 30</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Returns the collection, minus its first <code>n</code> elements.</p>
<p>If there are fewer than <code>n</code> elements in the collection, an empty iterator will be
returned instead..</p>
<pre class="prettyprint source lang-javascript"><code>const arr = drop(3)([1, 2, 3, 4, 5])
const str = drop(3)('testing')
const obj = drop(3)({ a: 1, b: 2, c: 3, d: 4, e: 5 })

console.log(collect(arr)) // [4, 5]
console.log(collect(str)) // 'ting'
console.log(collect(obj)) // { d: 4, e: 5 }
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>n</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>The number of elements to drop from the input collection.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">iterable</span>


            
            </td>

            

            

            <td class="description last"><p>The collection to drop elements from.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator of the elements of <code>x</code> after the first <code>n</code> of them.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".enumerate"><span class="type-signature">(generator, static) </span>enumerate<span class="signature">(x, start<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_enumerate.js.html">iterators/enumerate.js</a>, <a href="iterators_enumerate.js.html#line31">line 31</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Generates a set of pairs of iterable elements with their indices. This is inspired by
Python's <code>enumerate</code> function.</p>
<p>For arrays, these two statements do the same thing:</p>
<ul>
<li><code>for (const [i, value] of array.entries()) { ... }</code></li>
<li><code>for (const [i, value] of enumerate(array)) { ... }</code></li>
</ul>
<p>The difference is that <code>enumerate</code> works on <em>any</em> iterable, not only those that have
<code>entries</code> defined upon them.</p>
<p>This function also provides the option to start the index (the first element of the
yielded tuple) from a number other than 0. This number can be passed in as the optional
<code>start</code> parameter.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">iterable</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The collection to be enumerated.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>start</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>0</code>
                
                </td>
            

            <td class="description last"><p>The index of the first tuple that gets yielded. Every
succeeding tuple has its index incremented by 1.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator containing one entry for each element in <code>x</code>. Each entry
will be a two-element array of the index followed by the value.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".filter"><span class="type-signature">(generator, static) </span>filter<span class="signature">(fn, x)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_filter.js.html">iterators/filter.js</a>, <a href="iterators_filter.js.html#line33">line 33</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Filters the elements of an iterable, returning in an iterator only the ones that make a
filtering function return <code>true</code>.</p>
<pre class="prettyprint source lang-javascript"><code>// Filter odd numbers
const odd = pipe (swap (rem) (2)) (ne (0))
const result = filter (odd) ([1, 2, 3, 4, 5])

console.log(result.next().value) // 1
console.log(result.next().value) // 3
console.log(result.next().value) // 5
console.log(result.next().done)  // true
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A predicate function (a single-parameter function that returns a
boolean). This predicate is run once for every element of <code>x</code> with its argument set
to that element; the elements that cause the predicate to return <code>true</code> are the ones
that are retained in the result iterator.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The collection to filter.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator containing each element in <code>x</code> that makes <code>fn</code> return
<code>true</code> when applied to it.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".iterate"><span class="type-signature">(static) </span>iterate<span class="signature">(x)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_iterate.js.html">iterators/iterate.js</a>, <a href="iterators_iterate.js.html#line170">line 170</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates an iterator over the provided value.</p>
<p>For values that implement the iterable protocol (i.e., that have properties named
<code>Symbol.iterator</code> that evaluate to functions), It's as simple as that. Therefore, arrays,
strings, and any custom objects that implement the iterable protocol work right out of
the box.</p>
<pre class="prettyprint source"><code>const iter = iterate([1, 2, 3]);

console.log(iter.next().value) // 1
console.log(iter.next().value) // 2
console.log(iter.next().value) // 3
console.log(iter.next().done)  // true
</code></pre>
<p>Generic objects get special support. If an object (meaning an object literal or something
created with <code>Object.create()</code>, but not custom classes, which have to implement the
iterable protocol explicitly) is passed to <code>iterate</code>, a new iterator will be returned
that iterates over everything that <code>Object.keys</code> returns for that object This will come
out in the &quot;natural&quot; property order, as follows:</p>
<ol>
<li>Integer indices, in numerical order. (This does include strings that convert to
integers, such as <code>'2'</code>, but not strings that do not directly correspond to an integer
even if they are convertible to integers, such as <code>'02'</code>.)</li>
<li>String property names, in the order in which they were added to the object.</li>
</ol>
<p>Symbol-keyed properties are not included by this iterator as symbols are intended to be
used for non-enumerable information (neither <code>Object.keys</code>, <code>Object.entries</code>, or
<code>for...in</code> loops include them either, even if they're made enumerable).</p>
<p>The values that this iterator provides are two-element arrays, in which the first element
is the key and the second is the value.</p>
<pre class="prettyprint source"><code>const iter = iterate({ b: 2, a: 4 });

console.log(iter.next().value) // ['b',2]
console.log(iter.next().value) // ['a',4]
console.log(iter.next().done)  // true
</code></pre>
<p>This does not modify the object itself, so it's not actually made &quot;iterable&quot; in any other
sense. It's explicit support for objects in this context and nothing more.</p>
<p>If this function is provided a <em>function</em> as its first argument, an iterator is returned
which runs that function one time for each call to <code>next</code>. That function is provided two
arguments: the index of the call (starting at <code>0</code> for the first time it's called and
increasing by 1 per invocation after that) and the return value of the previous call to
the function (starting at <code>undefined</code> for the first run before the function is ever
called). If the function ever returns <code>undefined</code>, the iterator will terminate and set
the <code>done</code> property of its return value to <code>true</code> at that point.</p>
<p>Note that since the initial value of the second argument is <code>undefined</code>, using default
arguments is an excellent way of providing the function an initial value.</p>
<pre class="prettyprint source"><code>const constIter = iterate(() => 6)   // Bert's favorite number
console.log(constIter.next().value)   // 6
console.log(constIter.next().value)   // 6
// This will go on forever, as long as `next` keeps getting called

const indexIter = iterate(x => x * x)
console.log(indexIter.next().value)   // 0
console.log(indexIter.next().value)   // 1
console.log(indexIter.next().value)   // 4
console.log(indexIter.next().value)   // 9
// Again, this will go on forever, or until the numbers get to big JS to handle

// Using default value on `last` parameter for initial value
const lastIter = iterate((index, last = 1) => last * (index + 1))  // Factorial
console.log(lastIter.next().value)    // 1
console.log(lastIter.next().value)    // 2
console.log(lastIter.next().value)    // 6
console.log(lastIter.next().value)    // 24
// Again, forever, though factorials get big quickly

// This iterator will terminate when the function returns `undefined`
const stopIter = iterate(x => x &lt; 2 ? x : undefined)
console.log(stopIter.next().value)    // 0
console.log(stopIter.next().value)    // 1
console.log(stopIter.next().done)     // true
</code></pre>
<p>If the argument is none of these things, then an iterator is returned that yields that
argument one time before completing.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to be iterated over.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator over the provided value. If the value is not iterable
(it's not an object or a function, and it doesn't have a protocol-defined iterator),
an iterator that returns only that value once is returned.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".map"><span class="type-signature">(generator, static) </span>map<span class="signature">(fn, x)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_map.js.html">iterators/map.js</a>, <a href="iterators_map.js.html#line29">line 29</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Passes each element of an iterable to a mapping function, returning the results in an
iterator.</p>
<pre class="prettyprint source lang-javascript"><code>const result = map (add(1)) ([1, 2, 3])
console.log(result.next().value) // 2
console.log(result.next().value) // 3
console.log(result.next().value) // 4
console.log(result.next().done)  // true
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A one-parameter function. Each element of <code>iterable</code> is used as an
argument to this function, and its return values are yielded by the resulting
iterator.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The collection to map.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator containing the return values of <code>fn</code> when applied to each
of the elements of <code>x</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".range"><span class="type-signature">(generator, static) </span>range<span class="signature">(start<span class="signature-attributes">opt</span>, end, step<span class="signature-attributes">opt</span>, inclusive<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_range.js.html">iterators/range.js</a>, <a href="iterators_range.js.html#line73">line 73</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Generates a range of numbers. This is inspired by Python's <code>range</code> function.</p>
<p>This generator yields a range of numbers, starting with <code>start</code> and incrementing each
succeeding number by <code>step</code> until <code>end</code> is reached. If <code>inclusive</code> is true, then <code>end</code>
itself can be included in the range.</p>
<p>If only one numeric parameter is provided, it is assumed to be <code>end</code>. Two numbers are
interpreted as <code>start</code> and <code>end</code>. In any cases where they aren't specified, <code>start</code> is
<code>0</code> and <code>step</code> is <code>1</code>.</p>
<p>If <code>start</code> is greater than <code>end</code>, the range will run in reverse. In this case, each
successive number is <em>de</em>cremented by <code>step</code>. <code>step</code> itself should always be positive; if
a negative <code>step</code> is provided, its absolute value will be used instead, and if <code>0</code> is
provided, it will be regarded as <code>1</code>. The direction of the iteration is always determined
by <code>start</code> and <code>end</code>.</p>
<pre class="prettyprint source lang-javascript"><code>// Using collect to change iterators to arrays for ease of display
const e = collect(range(4))
console.log(e)    // [0,1,2,3]

const ei = collect(range(4, true))
console.log(ei)   // [0,1,2,3,4]

const se = collect(range(2, 4))
console.log(se)   // [2,3]

// 0 is necessary because range(4, 2) would be interpreted as a
// start of 4 and end of 2, producing [4,3]
const sep = collect(range(0, 4, 2))
console.log(sep)  // [0,2]

const sepi = collect(range(0, 4, 2, true))
console.log(sepi) // [0,2,4]

// Probably the most common use: in `for...of` loops
const a = [0, 1, 2, 3]
const b = [0, 5, 10, 15]
const c = []
// reversed; range produces 3, 2, 1, 0
for (const i of range(3, 0, true)) {
  c.push(a[i] * b[i])
}
console.log(c)    // [45,20,5,0]

// Sometimes you just need a loop to run x times without caring
// about the index; suggest using _ in that case
function line(length) {
  let result = ''
  for (const _ of range(length)) result += '-'
  return result
}
console.log(line(10))  // &quot;----------&quot;
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Attributes</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>start</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>0</code>
                
                </td>
            

            <td class="description last"><p>The first number of the range.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>end</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The last number of the range. By default this number forms the upper
bound of the range without being included in it.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>step</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>1</code>
                
                </td>
            

            <td class="description last"><p>The number to increase the yielded value by during each
iteration.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>inclusive</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    <code>false</code>
                
                </td>
            

            <td class="description last"><p>Determines whether <code>end</code> should be included as part of
the range.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator of numbers that make up the range, according to all of
the parameters above.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".reduce"><span class="type-signature">(static) </span>reduce<span class="signature">(fn, x)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_reduce.js.html">iterators/reduce.js</a>, <a href="iterators_reduce.js.html#line69">line 69</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Reduces an iterable with a function.</p>
<p>This function will apply the reducer function <code>fn</code> to the first two elements of the input
iterable, and then will apply the same reducer function to that result and the next
element of the iterable, repeating until there are no elements left. The result is a
single answer, which is returned.</p>
<p><strong><code>reduce</code> is not lazy.</strong> By its nature, it must evaluate an entire iterator to work and
is thus not suitable for infinite iterators.</p>
<p>Use of this function is done a little differently than traditional <code>Array.reduce</code>. It
does not have the option of an initial value. This means two things: first, the reduction
of a single-element iterable will just be that single element itself, and second, the
reducer function needs to have both arguments and the return value be of the same type.
This is contrary to <code>Array.reduce</code>, which has a first argument and return value of the
same type but which can take a different type for the second argument.</p>
<p>The upshot is that using a <code>map</code> before the <code>reduce</code> is suggested in many scenarios
where, in traditional JavaScript reduction, you would do that mapping as a part of the
reducer function itself. For example, if one wanted to turn an array of digits into
strings and then concatenate them, the <code>Array.reduce</code> way would be like this:</p>
<pre class="prettyprint source lang-javascript"><code>const fn = (acc, value) => acc + value.toString()
function stringify(xs) {
  return xs.reduce(fn, '')
}
</code></pre>
<p>This maps the values in the middle of the reducer function (the <code>toString</code> call) and
wouldn't work as well with this iterator <code>reduce</code>. Instead, you would want to do this:</p>
<pre class="prettyprint source lang-javascript"><code>function stringify(xs) {
  const mapped = map(x => x.toString(), xs)
  return reduce((x, y) => x + y, mapped)
}
</code></pre>
<p>Though in reality, with the other functions in this library, it would be even better to
do this:</p>
<pre class="prettyprint source lang-javascript"><code>const stringify = compose (reduce (add), map (string))
</code></pre>
<p>Requiring the reducer function to take two arguments of the same type makes you have to
think more about the kind of reduction you want to do, but it makes it easier to use
functions you already have lying around to do things in a more concise and understandable
manner.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The reducer function, a function of two parameters that will receive
the current value and the next element as arguments.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The collection to reduce. This can be of any type; a non-iterable value will
be transformed into an array containing only that value.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The result of the reducer function's last call.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".reverse"><span class="type-signature">(generator, static) </span>reverse<span class="signature">(x)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_reverse.js.html">iterators/reverse.js</a>, <a href="iterators_reverse.js.html#line29">line 29</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Reverses the order of an iterable.</p>
<p><strong><code>reverse</code> should not be used with infinite iterators.</strong> By its nature, it must evaluate
an entire iterator so that it can find the end, which is where the new iterator will
begin. Thus it returns a lazy value (an iterator), but it eagerly evaluates its input.</p>
<pre class="prettyprint source lang-javascript"><code>const arr = reverse ([1, 2, 3, 4, 5])
const str = reverse ('test')
const fn = reverse (x => (x &lt; 5 ? x : undefined))

console.log(arr) // [5, 4, 3, 2, 1]
console.log(str) // [&quot;t&quot;, &quot;s&quot;, &quot;e&quot;, &quot;t&quot;]
console.log(fn)  // [4, 3, 2, 1, 0]
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The collection to reverse.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator over a version of <code>x</code> with its elements in reverse order.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".scan"><span class="type-signature">(generator, static) </span>scan<span class="signature">(fn, x)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_scan.js.html">iterators/scan.js</a>, <a href="iterators_scan.js.html#line68">line 68</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Reduces an iterable with a function, returning an iterator with all of the intermediate
results.</p>
<p>This acts very much like <code>reduce</code>, except instead of returning the final answer, it
returns the intermediate values from each time the function is run (in an iterator). The
first value is prepended unmodified to the iterator; this is to ensure that the length of
the result of <code>scan</code> is the same as the length of the input.</p>
<p>Use of this function is done a little differently than traditional <code>Array.reduce</code>. It
does not have the option of an initial value. The first calculated value is just the
result of the reducer function <code>fn</code> applied to the first two elements of the input. This
means that the reduction function needs to be able to handle both an input element and an
&quot;accumulator&quot; as its first argument.</p>
<p>Because the initial value in the result iterator will not be passed through the reducer
function, it's often best to use <code>map</code> before <code>scan</code> rather than depend on the reducer
function to do its own mapping, as is often done in JavaScript. For instance, if a
reducer function makes characters uppercase, it will still not affect the first value in
the output iterator; that value is never passed through the reducer function. Mapping to
uppercase and <em>then</em> scanning may be better.</p>
<p>Also, since the first invocation of the reducer function is sent two elements rather than
an accumulator value and an element, it's important to be sure that any &quot;mapping&quot; is done
on both arguments. For instance, a scan that is supposed to turn numbers into strings and
then concatenate them will have to be sure that <em>both</em> arguments are turned to strings,
since the first invocation will receive two numbers rather than a string and a number. It
would probably be best to map the numbers to strings <em>first</em> and then concatenate them
with <code>scan</code> after.</p>
<p><code>scan</code> is a curried function and can therefore easily be partially applied. It accepts a
reducer function that can be curried or uncurried.</p>
<pre class="prettyprint source lang-javascript"><code>const runningSum = scan (add) ([0, 1, 2, 3, 4])
console.log(runningSum.next().value)  // 0
console.log(runningSum.next().value)  // 1
console.log(runningSum.next().value)  // 3
console.log(runningSum.next().value)  // 6
console.log(runningSum.next().value)  // 10

const mulScan = scan (mul)
const factorial = mulScan ([1, 2, 3, 4, 5])
console.log(factorial.next().value)   // 1
console.log(factorial.next().value)   // 2
console.log(factorial.next().value)   // 6
console.log(factorial.next().value)   // 24
console.log(factorial.next().value)   // 120
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The reducer function, a function of two parameters that will receive
the current value and the next element as arguments.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The collection to scan. This can be of any type; a non-iterable value will
be transformed into an array containing only that value.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator containing each of the return values of the reducer
function <code>fn</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".take"><span class="type-signature">(generator, static) </span>take<span class="signature">(n, x)</span><span class="type-signature"> &rarr; {iterator}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="iterators_take.js.html">iterators/take.js</a>, <a href="iterators_take.js.html#line31">line 31</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Returns the first <code>n</code> elements of a collection.</p>
<p>If there are fewer than <code>n</code> elements in the collection already, the collection will be
returned. No additional elements will be added to it.</p>
<pre class="prettyprint source lang-javascript"><code>const arr = take(3)([1, 2, 3, 4, 5])
const str = take(3)('testing')
const obj = take(3)({ a: 1, b: 2, c: 3, d: 4, e: 5 })

console.log(collect(arr)) // [1, 2, 3]
console.log(collect(str)) // 'tes'
console.log(collect(obj)) // { a: 1, b: 2, c: 3 }
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>n</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>The number of elements to take from the input collection.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">iterable</span>


            
            </td>

            

            

            <td class="description last"><p>The collection to take elements from.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator of the first <code>n</code> elements of <code>x</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">iterator</span>


    </dd>
</dl>

    



        
    

    

    
</article>

</section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>